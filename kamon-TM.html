<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>å®¶ç´‹åˆ†é¡ã‚µã‚¤ãƒˆï¼ˆTeachable Machine + OpenCV.jsï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: "Segoe UI", "Hiragino Kaku Gothic ProN", sans-serif; background:#fff; color:#000; text-align:center; margin:2rem;}
    h1 { font-size:2rem; margin-bottom:0.5rem;}
    #status { margin:1rem 0; color:#000;}
    input[type=file]{margin:1rem;}
    canvas{margin-top:1rem; max-width:60%; border:1px solid #444;}
    .result{margin-top:1rem; font-size:1.2rem;}
  </style>
</head>

<body>
  <h1>ğŸ¯ å®¶ç´‹åˆ†é¡ã‚µã‚¤ãƒˆ</h1>
  <p>ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã¨ã€AIãŒ <b>ä¸¸ãƒ»å››è§’ãƒ»ä¸‰è§’ãƒ»ãªã—</b> ã®ã„ãšã‚Œã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚</p>

  <p id="status">â³ ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸­...</p>
  <input type="file" id="file" accept="image/*">
  <canvas id="canvas"></canvas>
  <div class="result" id="result"></div>

 <!-- TensorFlow.js -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>

<!-- Teachable Machine -->
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8/dist/teachablemachine-image.min.js"></script>

<!-- OpenCV.jsï¼ˆå®‰å®šCDNï¼‹ç¢ºèªä»˜ãï¼‰ -->
<script async 
  src="https://docs.opencv.org/4.x/opencv.js"
  onload="document.getElementById('status').textContent += ' âœ… OpenCV.jsèª­ã¿è¾¼ã¿æˆåŠŸ';"
  onerror="alert('âš ï¸ OpenCV.jsã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚');">
</script>


  <script>
    const MODEL_URL = "https://teachablemachine.withgoogle.com/models/JssL1cK-Y/";  // â† ã‚ãªãŸã®ãƒ¢ãƒ‡ãƒ«URLã«ç½®ãæ›ãˆ
    let tmModel;

    const statusEl = document.getElementById('status');
    const fileInput = document.getElementById('file');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const resultEl = document.getElementById('result');

    // ---- ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚€ ----
    async function loadModel() {
      try {
        const modelURL = MODEL_URL + "model.json";
        const metadataURL = MODEL_URL + "metadata.json";
        tmModel = await tmImage.load(modelURL, metadataURL);
        statusEl.textContent = "âœ… ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†ï¼ç”»åƒã‚’é¸ã‚“ã§ãã ã•ã„ã€‚";
      } catch (err) {
        console.error(err);
        statusEl.textContent = "âŒ ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—ï¼šURLã‚„ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚";
      }
    }

    loadModel();

    // ---- ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠæ™‚ ----
    fileInput.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file || !tmModel) return;

      const img = new Image();
      img.onload = async () => {
        // Canvasã«æç”»
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);

        // TMãƒ¢ãƒ‡ãƒ«ã§æ¨è«–
        const prediction = await tmModel.predict(img);
        prediction.sort((a, b) => b.probability - a.probability);
        const top = prediction[0];

        resultEl.innerHTML = `ğŸ” çµæœï¼š<b>${top.className}</b>ï¼ˆç¢ºç‡ ${(top.probability*100).toFixed(1)}%ï¼‰`;

        // OpenCVã§å›²ã¿ã‚’æç”»ï¼ˆã‚‚ã—å½¢ãŒã‚ã‚Œã°ï¼‰
        // OpenCVã§å›²ã¿ã‚’æç”»ï¼ˆå¤–æ ã¯é™¤å¤–ï¼‰
if (typeof cv !== 'undefined') {
  const src = cv.imread(canvas);
  const gray = new cv.Mat();
  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

  // ç·šãŒé»’ãƒ»èƒŒæ™¯ãŒç™½ã®ç”»åƒãŒå¤šã„ãªã‚‰ â€œç·šã‚’ç™½â€ ã«ã™ã‚‹æ–¹ãŒè¼ªéƒ­ãŒå–ã‚Šã‚„ã™ã„
  // å¿…è¦ã«å¿œã˜ã¦ THRESH_BINARY ã«æˆ»ã—ã¦ãã ã•ã„
  cv.threshold(gray, gray, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);

  // ãƒã‚¤ã‚ºé™¤å»ï¼ˆç´°ã‹ã„ç‚¹ã‚’æ¶ˆã™ï¼‰
  const kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 3));
  cv.morphologyEx(gray, gray, cv.MORPH_OPEN, kernel);
  kernel.delete();

  const contours = new cv.MatVector();
  const hierarchy = new cv.Mat();
  cv.findContours(gray, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  const W = src.cols, H = src.rows;
  const MIN_AREA  = 400;      // å°ã•ã™ãã‚‹ã‚´ãƒŸã‚’é™¤å¤–
  const MAX_FRAC  = 0.90;     // ç”»åƒé¢ç©ã®90%ã‚’è¶…ãˆã‚‹å·¨å¤§è¼ªéƒ­ã¯é™¤å¤–
  const EDGE_MGN  = 2;        // ç«¯ã‹ã‚‰2pxä»¥å†…ã«è§¦ã‚Œã¦ã„ãŸã‚‰å¤–æ ã¨ã¿ãªã™

  let vis = src.clone();

  for (let i = 0; i < contours.size(); ++i) {
    const cnt = contours.get(i);
    const area = cv.contourArea(cnt);
    if (area < MIN_AREA) { cnt.delete(); continue; }

    const r = cv.boundingRect(cnt);

    const touchesEdge =
      r.x <= EDGE_MGN ||
      r.y <= EDGE_MGN ||
      (r.x + r.width)  >= (W - EDGE_MGN) ||
      (r.y + r.height) >= (H - EDGE_MGN);

    const isHuge = area > MAX_FRAC * W * H;

    // â˜… å¤–æ ãƒ»ç«¯æ¥è§¦ãƒ»å·¨å¤§è¼ªéƒ­ã¯ã‚¹ã‚­ãƒƒãƒ—
    if (touchesEdge || isHuge) { cnt.delete(); continue; }

    // ã“ã“ã‹ã‚‰å¯è¦–åŒ–ï¼ˆå¿…è¦ã«å¿œã˜ã¦è‰²ã‚’å¤‰ãˆã¦OKï¼‰
    cv.rectangle(
      vis,
      new cv.Point(r.x, r.y),
      new cv.Point(r.x + r.width, r.y + r.height),
      new cv.Scalar(0, 255, 0, 255),
      2
    );

    cnt.delete();
  }

  cv.imshow(canvas, vis);
  vis.delete();
  src.delete(); gray.delete(); contours.delete(); hierarchy.delete();
}

      };
      img.src = URL.createObjectURL(file);
    });
  </script>
</body>
</html>






