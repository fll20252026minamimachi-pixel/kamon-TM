<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>AIå›³å½¢æ¤œå‡ºï¼ˆä¸¸ãƒ»å››è§’ãƒ»ä¸‰è§’ï¼‰</title>
<style>
  body { font-family: sans-serif; margin: 20px; text-align: center; }
  canvas { border: 1px solid #ccc; max-width: 90%; height: auto; margin-top: 10px; }
  #status { font-weight: bold; margin: 10px 0; }
</style>
</head>
<body>
<h1>ğŸ”µ AIã§å›³å½¢ã‚’æ¤œå‡ºï¼</h1>
<p>Teachable Machineã§å­¦ç¿’ã—ãŸã€Œä¸¸ãƒ»å››è§’ãƒ»ä¸‰è§’ãƒ»ãªã—ã€ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ã£ã¦ã€ç”»åƒä¸­ã®å›³å½¢ã‚’è‡ªå‹•ã§ãƒãƒ¼ã‚¯ã—ã¾ã™ã€‚</p>

<p id="status">â³ ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ä¸­...</p>
<input type="file" id="file" accept="image/*"><br>
<canvas id="canvas"></canvas>

<!-- TensorFlow.js & Teachable Machine -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image"></script>

<script>
const MODEL_URL = "https://teachablemachine.withgoogle.com/models/JssL1cK-Y/"; // â†ã“ã“ã‚’è‡ªåˆ†ã®URLã«ï¼
let tmModel;
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const fileInput = document.getElementById("file");
const statusEl = document.getElementById("status");

// ===== ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ =====
async function loadModel() {
  const modelURL = MODEL_URL + "model.json";
  const metadataURL = MODEL_URL + "metadata.json";
  try {
    tmModel = await tmImage.load(modelURL, metadataURL);
    statusEl.textContent = "âœ… ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†ï¼ç”»åƒã‚’é¸ã‚“ã§ãã ã•ã„ã€‚";
  } catch (err) {
    statusEl.textContent = "âŒ ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚URLã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚";
    console.error(err);
  }
}

loadModel();

// ===== ç”»åƒèª­ã¿è¾¼ã¿ =====
fileInput.addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file || !tmModel) return;
  const img = new Image();
  img.onload = async () => {
    // Canvasã«æç”»
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0, img.width, img.height);
    // åˆ†å‰²ã‚¹ã‚­ãƒ£ãƒ³é–‹å§‹
    await scanAndMark(img);
  };
  img.src = URL.createObjectURL(file);
});

// ===== ã‚¹ã‚­ãƒ£ãƒ³ã—ã¦å›³å½¢ã‚’æ¤œå‡º =====
async function scanAndMark(imgEl) {
  const boxSize = 64;   // ãƒã‚§ãƒƒã‚¯ã™ã‚‹å°ãƒ–ãƒ­ãƒƒã‚¯ã®å¤§ãã•
  const stride = 32;    // ç§»å‹•é–“éš”ï¼ˆé‡ãªã‚Šï¼‰
  const threshold = 0.8; // å›³å½¢ã£ã½ã„ç¢ºç‡ã®ã—ãã„å€¤
  const labelsColor = {
    "ä¸¸": "blue",
    "å››è§’": "green",
    "ä¸‰è§’": "red"
  };

  const tempCanvas = document.createElement("canvas");
  const tempCtx = tempCanvas.getContext("2d");
  tempCanvas.width = imgEl.width;
  tempCanvas.height = imgEl.height;

  const boxes = [];

  for (let y = 0; y < imgEl.height - boxSize; y += stride) {
    for (let x = 0; x < imgEl.width - boxSize; x += stride) {
      tempCtx.drawImage(imgEl, x, y, boxSize, boxSize, 0, 0, boxSize, boxSize);
      const prediction = await tmModel.predict(tempCanvas);
      prediction.sort((a, b) => b.probability - a.probability);
      const best = prediction[0];
      if (best.className !== "ãªã—" && best.probability > threshold) {
        boxes.push({ x, y, label: best.className, conf: best.probability });
      }
    }
  }

  // æ ã‚’æç”»
  boxes.forEach(b => {
    ctx.strokeStyle = labelsColor[b.label] || "yellow";
    ctx.lineWidth = 2;
    ctx.strokeRect(b.x, b.y, boxSize, boxSize);
    ctx.fillStyle = labelsColor[b.label];
    ctx.font = "16px sans-serif";
    ctx.fillText(`${b.label} (${(b.conf*100).toFixed(0)}%)`, b.x + 4, b.y + 20);
  });

  statusEl.textContent = `ğŸ” æ¤œå‡ºå®Œäº†ï¼ æ¤œå‡ºæ•°ï¼š${boxes.length}`;
}
</script>
</body>
</html>

